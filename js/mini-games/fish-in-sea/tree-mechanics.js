// js/mini-games/fish-in-sea/tree-mechanics.js

let treeSlots = [null, null, null, null, null, null, null, null];
let treeMoisture = 100;
const MAX_MOISTURE = 100;
let constantMoistureActive = false;
const MATURATION_TIME = 10000; // 10 seconds to mature at 100% moisture
const SPAWN_TIME = 5000; // 5 seconds to spawn a new fruit

let slotTimers = [0, 0, 0, 0, 0, 0, 0, 0];
let maturationProgress = [0, 0, 0, 0, 0, 0, 0, 0]; // Stores actual percentage for each slot

// Rarity distribution for cards generated by the tree
const treeRarityWeights = {
    base: 70,
    rare: 20,
    foil: 7,
    holo: 3
    // star: 0, // Can add other rarities if desired
    // rainy: 0,
    // gold: 0,
    // shiny: 0
};

/**
 * Helper function to get a random rarity key based on weights.
 */
function getRandomRarityFromWeights(weights) {
    let totalWeight = 0;
    for (const rarity in weights) {
        totalWeight += weights[rarity];
    }
    let randomNum = Math.random() * totalWeight;
    for (const rarity in weights) {
        if (randomNum < weights[rarity]) {
            return rarity;
        }
        randomNum -= weights[rarity];
    }
    return null; // Fallback, should not be reached if weights are valid
}

/**
 * Generates a random card for the tree based on defined rarities.
 */
function generateRandomCardForTree() {
    const targetRarityKey = getRandomRarityFromWeights(treeRarityWeights);
    if (!targetRarityKey) {
        console.error("Tree: Could not determine target rarity from weights.");
        return null;
    }

    if (typeof getActiveSetDefinitions !== 'function' ||
        typeof cardData === 'undefined' ||
        typeof getFixedGradeAndPrice !== 'function' ||
        typeof getCardImagePath !== 'function' ||
        typeof getCardIntrinsicRarity !== 'function') {
        console.error("Tree: Missing critical global functions or data for card generation (getActiveSetDefinitions, cardData, getFixedGradeAndPrice, getCardImagePath, getCardIntrinsicRarity).");
        return null;
    }

    const activeSets = getActiveSetDefinitions();
    if (!activeSets || activeSets.length === 0) {
        console.error("Tree: No active sets available for card generation.");
        return null;
    }

    const possibleCards = [];
    activeSets.forEach(setDef => {
        if (cardData[setDef.abbr]) {
            for (const cardIdKey in cardData[setDef.abbr]) {
                const cardIdNum = parseInt(cardIdKey);
                if (getCardIntrinsicRarity(setDef.abbr, cardIdNum) === targetRarityKey) {
                    const cardEntry = cardData[setDef.abbr][cardIdKey]; // Get base card name if available
                    const fixedProps = getFixedGradeAndPrice(setDef.abbr, cardIdNum);
                    possibleCards.push({
                        set: setDef.abbr,
                        id: cardIdNum,
                        name: cardEntry.name || `${setDef.name} Card #${cardIdNum}`,
                        rarity: fixedProps.rarityKey, // This will be the actual rarity after fixedProps
                        price: fixedProps.price,
                        grade: fixedProps.grade,
                        imagePath: getCardImagePath(setDef.abbr, cardIdNum),
                        type: 'collectible_card'
                    });
                }
            }
        }
    });

    if (possibleCards.length > 0) {
        return possibleCards[Math.floor(Math.random() * possibleCards.length)];
    } else {
        console.warn(`Tree: No cards found for target rarity '${targetRarityKey}'. Trying a fallback to 'base' rarity.`);
        // Fallback: try to get any 'base' card if specific rarity fails
        activeSets.forEach(setDef => {
            if (cardData[setDef.abbr]) {
                for (const cardIdKey in cardData[setDef.abbr]) {
                    const cardIdNum = parseInt(cardIdKey);
                    if (getCardIntrinsicRarity(setDef.abbr, cardIdNum) === 'base') {
                         const cardEntry = cardData[setDef.abbr][cardIdKey];
                         const fixedProps = getFixedGradeAndPrice(setDef.abbr, cardIdNum);
                         possibleCards.push({
                            set: setDef.abbr, id: cardIdNum, name: cardEntry.name || `${setDef.name} Card #${cardIdNum}`,
                            rarity: fixedProps.rarityKey, price: fixedProps.price, grade: fixedProps.grade,
                            imagePath: getCardImagePath(setDef.abbr, cardIdNum), type: 'collectible_card'
                        });
                    }
                }
            }
        });
        if (possibleCards.length > 0) {
            return possibleCards[Math.floor(Math.random() * possibleCards.length)];
        }
    }
    console.error("Tree: Failed to generate any card, even fallback 'base' card.");
    return null;
}


function initializeTree() {
    treeSlots = Array(8).fill(null);
    treeMoisture = 100;
    constantMoistureActive = false;
    slotTimers = Array(8).fill(0);
    maturationProgress = Array(8).fill(0);

    if (typeof fishingTreeUi !== 'undefined' && typeof fishingTreeUi.renderTreeSlots === 'function') {
        fishingTreeUi.renderTreeSlots(getTreeSlotsData());
    }
    if (typeof fishingTreeUi !== 'undefined' && typeof fishingTreeUi.updateMoistureDisplay === 'function') {
        fishingTreeUi.updateMoistureDisplay(treeMoisture);
    }
    console.log("Tree initialized");
}

function setConstantMoistureSupply(isActive) {
    constantMoistureActive = isActive;
    if (isActive) {
        treeMoisture = MAX_MOISTURE;
        if (typeof fishingTreeUi !== 'undefined' && typeof fishingTreeUi.updateMoistureDisplay === 'function') {
            fishingTreeUi.updateMoistureDisplay(treeMoisture);
        }
        console.log("Constant moisture supply ACTIVE. Tree moisture set to max.");
    } else {
        console.log("Constant moisture supply DEACTIVATED.");
    }
}

function updateTreeFruitGrowth(deltaTime) {
    if (constantMoistureActive) {
        treeMoisture = MAX_MOISTURE;
        // Potentially call UI update if moisture is visually represented and can change even when constant.
        // if (typeof fishingTreeUi !== 'undefined' && typeof fishingTreeUi.updateMoistureDisplay === 'function') {
        //     fishingTreeUi.updateMoistureDisplay(treeMoisture);
        // }
    }

    let slotsChanged = false;
    for (let i = 0; i < treeSlots.length; i++) {
        if (treeSlots[i] === null) { // Slot is empty
            slotTimers[i] += deltaTime;
            if (slotTimers[i] >= SPAWN_TIME) {
                treeSlots[i] = {
                    state: "growing", // New state
                    maturation: 0
                    // No 'card' object here yet
                };
                maturationProgress[i] = 0;
                slotTimers[i] = 0;
                slotsChanged = true;
                console.log(`Slot ${i}: New unknown fruit/card started growing.`);
            }
        } else if (treeSlots[i].state === "growing" || treeSlots[i].state === "unmatured") { // Handle old "unmatured" as "growing"
            const moistureFactor = treeMoisture > 0 ? treeMoisture / MAX_MOISTURE : 0.1; // Min factor if no moisture
            let currentProgress = treeSlots[i].maturation || 0;
            currentProgress += (deltaTime / MATURATION_TIME) * 100 * moistureFactor;
            currentProgress = Math.min(currentProgress, 100);

            treeSlots[i].maturation = currentProgress;
            maturationProgress[i] = currentProgress;

            if (currentProgress >= 100) {
                const finalCardData = generateRandomCardForTree();
                if (finalCardData) {
                    treeSlots[i].state = "revealed";
                    treeSlots[i].card = finalCardData;
                    console.log(`Slot ${i}: Card matured and revealed as ${finalCardData.name} (${finalCardData.rarity})`);
                } else {
                    // Failed to generate a card, assign a very basic fallback and log error
                    console.error(`Slot ${i}: Failed to generate card data upon maturation. Assigning generic fallback.`);
                    treeSlots[i].state = "revealed"; // Still reveal, but with fallback
                    treeSlots[i].card = {
                        type: "generic_fruit_error",
                        name: "Mysterious Seed",
                        imagePath: "gui/fishing_game/fruit_placeholder.png", // Generic placeholder
                        rarity:"common", price:1, set:"fish_in_sea_fruit", id:"error_fruit"
                    };
                }
                slotsChanged = true;
            }
        }
        // Note: "revealed" slots are handled by collection logic, not here.
    }

    if (slotsChanged && typeof fishingTreeUi !== 'undefined' && typeof fishingTreeUi.renderTreeSlots === 'function') {
        fishingTreeUi.renderTreeSlots(getTreeSlotsData());
    }
}

function getTreeSlotsData() {
    return treeSlots.map((slot, index) => {
        if (slot) {
            let slotToReturn = {
                state: slot.state,
                maturation: maturationProgress[index] // Always use the synced progress
            };

            if (slot.state === "growing" || slot.state === "unmatured") { // Handle both new and potentially old state from save
                slotToReturn.card = {
                    type: "growing_fruit", // Generic type for UI
                    name: "Growing...",
                    imagePath: "gui/fishing_game/tree-back.png" // Image for the back of a growing card/fruit
                };
            } else if (slot.state === "revealed") {
                if (slot.card && slot.card.imagePath) {
                    slotToReturn.card = slot.card;
                } else { // Fallback for revealed card missing data (e.g. from old save or generation error)
                    console.warn("Revealed slot missing card data or imagePath. Assigning fallback for UI.", slot);
                    slotToReturn.card = {
                        type: "generic_fruit_fallback", name: "Revealed Fruit",
                        imagePath: "gui/fishing_game/fruit_placeholder.png",
                        rarity:"common", price:1, set:"fish_in_sea_fruit", id:"generic_fruit_fallback"
                    };
                }
            }
            // If slot.state is something else or card is missing, it'll be handled by UI with what's given
            return slotToReturn;
        }
        return null;
    });
}

function collectCardFromTree(slotIndex) {
    if (slotIndex < 0 || slotIndex >= treeSlots.length) {
        console.error(`Invalid slot index: ${slotIndex}`);
        return null;
    }

    const slot = treeSlots[slotIndex];
    if (slot && slot.state === "revealed" && slot.card) {
        const collectedCardDetails = slot.card;

        const cardDataForBasket = {
            id: collectedCardDetails.id || collectedCardDetails.type || `fruit_slot_${slotIndex}`,
            set: collectedCardDetails.set || (collectedCardDetails.type === 'collectible_card' ? 'unknown_set' : 'fish_in_sea_fruit'),
            name: collectedCardDetails.name || `${collectedCardDetails.type ? (collectedCardDetails.type.charAt(0).toUpperCase() + collectedCardDetails.type.slice(1)) : 'Mystic'} Item`,
            rarity: collectedCardDetails.rarityKey || collectedCardDetails.rarity || 'common',
            rarityKey: collectedCardDetails.rarityKey || collectedCardDetails.rarity || 'common',
            price: collectedCardDetails.price || (collectedCardDetails.type === 'collectible_card' ? 0 : 15),
            grade: collectedCardDetails.grade || (collectedCardDetails.type === 'collectible_card' ? 'S' : null),
            imagePath: collectedCardDetails.imagePath || (typeof getCardImagePath === 'function' ? getCardImagePath(collectedCardDetails.set, collectedCardDetails.id) : null) || `gui/fishing_game/${collectedCardDetails.type || 'fruit_placeholder'}.png`,
            source: 'tree',
            type: collectedCardDetails.type || (collectedCardDetails.set ? 'card' : 'fruit_card')
        };

        console.log(`Collecting item from slot ${slotIndex} directly to basket:`, cardDataForBasket);

        if (typeof window.fishingBasket !== 'undefined' && typeof window.fishingBasket.addCardToBasket === 'function') {
            window.fishingBasket.addCardToBasket(cardDataForBasket, 1);

            const displayData = {
                type: cardDataForBasket.type === 'collectible_card' ? 'card' : cardDataForBasket.type,
                details: cardDataForBasket,
                set: cardDataForBasket.set,
                id: cardDataForBasket.id,
                cardId: cardDataForBasket.id,
                name: cardDataForBasket.name,
                rarityKey: cardDataForBasket.rarityKey,
                grade: cardDataForBasket.grade,
                imagePath: cardDataForBasket.imagePath
            };

            if (typeof window.fishingUi !== 'undefined' && typeof window.fishingUi.showCaughtItemDisplay === 'function') {
                 window.fishingUi.showCaughtItemDisplay(displayData);
            } else if (typeof window.fishingUi !== 'undefined' && typeof window.fishingUi.showCatchPreview === 'function') {
                const previewItem = {
                    type: displayData.type === 'fruit_card' || displayData.type === 'collectible_card' ? 'card' : displayData.type,
                    details: {
                        set: displayData.set,
                        cardId: displayData.cardId,
                        rarityKey: displayData.rarityKey,
                        grade: displayData.grade,
                        name: displayData.name,
                        imagePath: displayData.imagePath
                    }
                };
                window.fishingUi.showCatchPreview(previewItem);
            } else if (typeof showTemporaryCollectedItem === 'function') {
                showTemporaryCollectedItem(displayData);
            }
        } else {
            console.warn("fishingBasket.addCardToBasket function not found. Card not added to basket.");
        }

        treeSlots[slotIndex] = null;
        maturationProgress[slotIndex] = 0;
        slotTimers[slotIndex] = 0;

        if (typeof fishingTreeUi !== 'undefined' && typeof fishingTreeUi.renderTreeSlots === 'function') {
            fishingTreeUi.renderTreeSlots(getTreeSlotsData());
        }
        console.log(`Slot ${slotIndex} cleared after collecting ${collectedCardDetails.name || 'item'}.`);
        return { ...collectedCardDetails };
    } else {
        console.log(`No revealed card to collect in slot ${slotIndex}. Current state: ${slot ? slot.state : 'empty'}`);
        return null;
    }
}

function updateTreeMoisture(newMoisture) {
    const oldMoisture = treeMoisture;
    if (!constantMoistureActive) {
        treeMoisture = Math.max(0, Math.min(newMoisture, MAX_MOISTURE));
    } else {
        treeMoisture = MAX_MOISTURE;
    }

    if (treeMoisture !== oldMoisture || constantMoistureActive) {
        if (typeof fishingTreeUi !== 'undefined' && typeof fishingTreeUi.updateMoistureDisplay === 'function') {
            fishingTreeUi.updateMoistureDisplay(treeMoisture);
        }
    }
    console.log(`Tree moisture updated to: ${treeMoisture}% (Constant moisture: ${constantMoistureActive})`);
}

function getTreeDataForSave() {
    return {
        treeSlots: treeSlots.map(slot => {
            // Only save essential data for "growing" state to avoid saving full placeholder card
            if (slot && (slot.state === "growing" || slot.state === "unmatured")) {
                return {
                    state: "growing", // Normalize to "growing" on save
                    maturation: slot.maturation
                };
            }
            return slot ? { ...slot } : null; // Save full slot data for other states (null, revealed)
        }),
        treeMoisture,
        slotTimers: [...slotTimers],
        maturationProgress: [...maturationProgress], // Save this to keep track of exact progress on load
        constantMoistureActive,
    };
}

function loadTreeData(data) {
    if (!data) {
        console.error("No data provided to loadTreeData.");
        initializeTree();
        return;
    }

    treeSlots = data.treeSlots ? data.treeSlots.map(slotData => {
        if (slotData && (slotData.state === "growing" || slotData.state === "unmatured")) {
            // Restore "growing" state correctly without a full card object initially
            return {
                state: "growing", // Normalize to "growing" on load
                maturation: slotData.maturation || 0,
                card: null // Ensure no card object for "growing" state on load
            };
        }
        return slotData ? { ...slotData } : null; // Load other states as is
    }) : Array(8).fill(null);

    treeMoisture = data.treeMoisture !== undefined ? data.treeMoisture : 100;
    slotTimers = data.slotTimers || Array(8).fill(0);
    // Ensure maturationProgress is correctly restored
    maturationProgress = data.maturationProgress && data.maturationProgress.length === 8 ?
                         [...data.maturationProgress] :
                         treeSlots.map(slot => slot ? (slot.maturation || 0) : 0); // Fallback if old save

    constantMoistureActive = data.constantMoistureActive || false;

    if (constantMoistureActive) {
        treeMoisture = MAX_MOISTURE;
    }

    if (typeof fishingTreeUi !== 'undefined' && typeof fishingTreeUi.renderTreeSlots === 'function') {
        fishingTreeUi.renderTreeSlots(getTreeSlotsData());
    }
    if (typeof fishingTreeUi !== 'undefined' && typeof fishingTreeUi.updateMoistureDisplay === 'function') {
        fishingTreeUi.updateMoistureDisplay(treeMoisture);
    }
    console.log("Tree data loaded:", getTreeDataForSave());
}

window.initializeTree = initializeTree;
// Expose other functions if they need to be called from elsewhere (e.g., UI interactions beyond collect)
window.setConstantMoistureSupply = setConstantMoistureSupply; // If UI controls this directly
window.updateTreeMoisture = updateTreeMoisture; // If UI or other systems can directly influence moisture
// getTreeSlotsData is used by fishingTreeUi, so it should be available.
// For safety, if it's not implicitly global due to script concatenation order, expose it.
if (typeof window.getTreeSlotsData === 'undefined') {
    window.getTreeSlotsData = getTreeSlotsData;
}
// collectCardFromTree is used by fishingTreeUi
if (typeof window.collectCardFromTree === 'undefined') {
    window.collectCardFromTree = collectCardFromTree;
}


console.log("tree-mechanics.js loaded with UI integration points and new generation logic.");

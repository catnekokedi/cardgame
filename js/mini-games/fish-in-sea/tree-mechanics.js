// js/mini-games/fish-in-sea/tree-mechanics.js

let treeSlots = [null, null, null, null, null, null, null, null];
let treeMoisture = 100;
const MAX_MOISTURE = 100;
let constantMoistureActive = false;
const MATURATION_TIME = 10000; // 10 seconds to mature at 100% moisture
const SPAWN_TIME = 5000; // 5 seconds to spawn a new fruit

let slotTimers = [0, 0, 0, 0, 0, 0, 0, 0];
let maturationProgress = [0, 0, 0, 0, 0, 0, 0, 0]; // Stores actual percentage for each slot

// Rarity distribution for cards generated by the tree
const treeRarityWeights = {
    base: 70,
    rare: 20,
    foil: 7,
    holo: 3
    // star: 0, // Can add other rarities if desired
    // rainy: 0,
    // gold: 0,
    // shiny: 0
};

/**
 * Helper function to get a random rarity key based on weights.
 */
function getRandomRarityFromWeights(weights) {
    let totalWeight = 0;
    for (const rarity in weights) {
        totalWeight += weights[rarity];
    }
    let randomNum = Math.random() * totalWeight;
    for (const rarity in weights) {
        if (randomNum < weights[rarity]) {
            return rarity;
        }
        randomNum -= weights[rarity];
    }
    return null; // Fallback, should not be reached if weights are valid
}

/**
 * Generates a random card for the tree based on defined rarities using utility functions.
 */
function generateRandomCardForTree() {
    // Keep existing typeof logs for dependencies for now for diagnostics // REMOVE THESE // Already commented
    // console.log('[TreeGen] typeof getActiveSetDefinitions:', typeof getActiveSetDefinitions); // REMOVED DEBUG
    // console.log('[TreeGen] typeof window.cardData:', typeof window.cardData, 'Keys:', Object.keys(window.cardData || {}).length); // REMOVED DEBUG
    // console.log('[TreeGen] typeof getFixedGradeAndPrice:', typeof getFixedGradeAndPrice); // REMOVED DEBUG
    // console.log('[TreeGen] typeof getCardImagePath:', typeof getCardImagePath); // REMOVED DEBUG
    // console.log('[TreeGen] typeof getCardIntrinsicRarity:', typeof getCardIntrinsicRarity); // REMOVED DEBUG
    // console.log('[TreeGen] typeof window.ALL_SET_DEFINITIONS:', typeof window.ALL_SET_DEFINITIONS); // REMOVED DEBUG

    if (typeof getActiveSetDefinitions !== 'function' ||
        typeof getFixedGradeAndPrice !== 'function' ||
        typeof getCardImagePath !== 'function' ||
        typeof getCardIntrinsicRarity !== 'function' ||
        typeof window.ALL_SET_DEFINITIONS === 'undefined') { // ALL_SET_DEFINITIONS is used by getActiveSetDefinitions
        console.error("Tree: Missing critical global functions or ALL_SET_DEFINITIONS for card generation.");
        return null; // Cannot proceed
    }

    const targetRarityKey = getRandomRarityFromWeights(treeRarityWeights);
    if (!targetRarityKey) {
        console.error("Tree: Could not determine target rarity from weights.");
        return null;
    }
    // console.log(`[TreeGen] Target Rarity Key: ${targetRarityKey}`); // DEBUG

    const activeSets = getActiveSetDefinitions(); // This should give { abbr: 'SET_CODE', name: 'Set Name', count: X, folderName: '...' }
    if (!activeSets || activeSets.length === 0) {
        console.error("Tree: No active sets available for card generation.");
        return null;
    }

    let possibleCards = [];
    activeSets.forEach(setDef => {
        if (!setDef || typeof setDef.abbr === 'undefined' || typeof setDef.count !== 'number') {
            // console.warn(`[TreeGen] Skipping set due to missing abbr or count:`, setDef); // INFO
            return; // Skip this set definition if it's malformed
        }

        for (let i = 1; i <= setDef.count; i++) { // Iterate from card ID 1 to setDef.count
            const cardIdNum = i;
            try {
                const intrinsicRarity = getCardIntrinsicRarity(setDef.abbr, cardIdNum);
                if (intrinsicRarity === targetRarityKey) {
                    const fixedProps = getFixedGradeAndPrice(setDef.abbr, cardIdNum); // Gets name, price, grade, actual rarityKey
                    if (fixedProps) {
                        possibleCards.push({
                            set: setDef.abbr,
                            id: cardIdNum,
                            name: fixedProps.name || `${setDef.name} Card #${cardIdNum}`, // Use name from fixedProps
                            rarity: fixedProps.rarityKey, // Use actual rarityKey from fixedProps
                            price: fixedProps.price,
                            grade: fixedProps.grade,
                            imagePath: getCardImagePath(setDef.abbr, cardIdNum, fixedProps.imageType || 'standard', fixedProps), // Pass fixedProps if getCardImagePath can use it for imageType
                            type: 'fruit_card',
                            source: 'tree'
                        });
                    } else {
                        // console.warn(`[TreeGen] getFixedGradeAndPrice returned null for ${setDef.abbr} - ${cardIdNum}`);
                    }
                }
            } catch (e) {
                // console.error(`[TreeGen] Error processing ${setDef.abbr} - ${cardIdNum}:`, e);
            }
        }
    });
    // console.log(`[TreeGen] Found ${possibleCards.length} cards for target rarity '${targetRarityKey}'.`); // DEBUG

    if (possibleCards.length > 0) {
        const selectedCard = possibleCards[Math.floor(Math.random() * possibleCards.length)];
        // console.log(`[TreeGenFinal] Generated: ID=${selectedCard.id}, Set=${selectedCard.set}, Name="${selectedCard.name}", Rarity=${selectedCard.rarity}, Image=${selectedCard.imagePath}`); // REMOVE - Aggressive cleanup
        return selectedCard;
    } else {
        // console.warn(`Tree: No cards found for target rarity '${targetRarityKey}'. Trying fallback to 'base' rarity.`); // REMOVED INFO
        // Fallback to 'base' rarity (similar loop but targetRarityKey is 'base')
        // Re-initialize possibleCards for fallback search
        possibleCards = [];
        activeSets.forEach(setDef => {
            if (!setDef || typeof setDef.abbr === 'undefined' || typeof setDef.count !== 'number') return;
            for (let i = 1; i <= setDef.count; i++) {
                const cardIdNum = i;
                try {
                    if (getCardIntrinsicRarity(setDef.abbr, cardIdNum) === 'base') {
                        const fixedProps = getFixedGradeAndPrice(setDef.abbr, cardIdNum);
                        if (fixedProps) {
                            possibleCards.push({
                                set: setDef.abbr, id: cardIdNum, name: fixedProps.name || `${setDef.name} Card #${cardIdNum}`,
                                rarity: fixedProps.rarityKey, price: fixedProps.price, grade: fixedProps.grade,
                                imagePath: getCardImagePath(setDef.abbr, cardIdNum, fixedProps.imageType || 'standard', fixedProps),
                                type: 'fruit_card', source: 'tree'
                            });
                        }
                    }
                } catch (e) { /* ignore */ }
            }
        });
        // console.log(`[TreeGen] Fallback: Found ${possibleCards.length} 'base' rarity cards.`); // REMOVED DEBUG
        if (possibleCards.length > 0) {
            const selectedCard = possibleCards[Math.floor(Math.random() * possibleCards.length)];
            // console.log(`[TreeGenFinal] Generated: ID=${selectedCard.id}, Set=${selectedCard.set}, Name="${selectedCard.name}", Rarity=${selectedCard.rarity}, Image=${selectedCard.imagePath}`); // REMOVE - Aggressive cleanup
            return selectedCard;
        }
    }

    console.error("Tree: Failed to generate any card, even fallback 'base' card.");
    return null; // Fallback if absolutely no card can be generated
}


function initializeTree() {
    treeSlots = Array(8).fill(null);
    treeMoisture = 100;
    constantMoistureActive = false;
    slotTimers = Array(8).fill(0);
    maturationProgress = Array(8).fill(0);

    if (typeof fishingTreeUi !== 'undefined' && typeof fishingTreeUi.renderTreeSlots === 'function') {
        fishingTreeUi.renderTreeSlots(getTreeSlotsData());
    }
    if (typeof fishingTreeUi !== 'undefined' && typeof fishingTreeUi.updateMoistureDisplay === 'function') {
        fishingTreeUi.updateMoistureDisplay(treeMoisture);
    }
    console.log("Tree initialized");
}

function setConstantMoistureSupply(isActive) {
    constantMoistureActive = isActive;
    if (isActive) {
        treeMoisture = MAX_MOISTURE;
        if (typeof fishingTreeUi !== 'undefined' && typeof fishingTreeUi.updateMoistureDisplay === 'function') {
            fishingTreeUi.updateMoistureDisplay(treeMoisture);
        }
        console.log("Constant moisture supply ACTIVE. Tree moisture set to max.");
    } else {
        console.log("Constant moisture supply DEACTIVATED.");
    }
}

function updateTreeFruitGrowth(deltaTime) {
    if (constantMoistureActive) {
        treeMoisture = MAX_MOISTURE;
    }

    let slotsChanged = false;
    for (let i = 0; i < treeSlots.length; i++) {
        if (treeSlots[i] === null) { // Slot is empty
            slotTimers[i] += deltaTime;
            if (slotTimers[i] >= SPAWN_TIME) {
                treeSlots[i] = {
                    state: "growing",
                    maturation: 0
                };
                maturationProgress[i] = 0;
                slotTimers[i] = 0;
                slotsChanged = true;
                // console.log(`Slot ${i}: New unknown fruit/card started growing.`); // INFO
            }
        } else if (treeSlots[i].state === "growing" || treeSlots[i].state === "unmatured") {
            const moistureFactor = treeMoisture > 0 ? treeMoisture / MAX_MOISTURE : 0.1;
            let currentProgress = treeSlots[i].maturation || 0;
            currentProgress += (deltaTime / MATURATION_TIME) * 100 * moistureFactor;
            currentProgress = Math.min(currentProgress, 100);

            treeSlots[i].maturation = currentProgress;
            maturationProgress[i] = currentProgress;

            if (currentProgress >= 100) {
                // console.log(`[TreeMechanics] updateTreeFruitGrowth: Slot ${i} matured. Attempting to generate card.`); // INFO
                const finalCardData = generateRandomCardForTree();
                // console.log(`[TreeMechanics] updateTreeFruitGrowth: Slot ${i} generated card data:`, finalCardData ? finalCardData.name : "None"); // INFO (TreeGenFinal is more specific)

                if (finalCardData) {
                    treeSlots[i].state = "revealed";
                    treeSlots[i].card = finalCardData; // finalCardData now includes type: 'fruit_card' and source: 'tree'
                    // console.log(`[TreeMechanics] updateTreeFruitGrowth: Slot ${i} successfully revealed as ${finalCardData.name} (${finalCardData.rarity})`); // INFO (TreeGenFinal is more specific)
                } else {
                    console.error(`[TreeMechanics] updateTreeFruitGrowth: Slot ${i} still failed to generate card after generateRandomCardForTree. Using error fallback.`);
                    treeSlots[i].state = "revealed";
                    treeSlots[i].card = {
                        type: "error_card_generation",
                        name: "Unreadable Card",
                        imagePath: "gui/fishing_game/tree-back.png",
                        rarity: "unknown",
                        price: 0,
                        set: "fish_in_sea_error",
                        id: "error_card"
                    };
                }
                slotsChanged = true;
            }
        }
    }

    if (slotsChanged && typeof fishingTreeUi !== 'undefined' && typeof fishingTreeUi.renderTreeSlots === 'function') {
        fishingTreeUi.renderTreeSlots(getTreeSlotsData());
    }
}

function getTreeSlotsData() {
    return treeSlots.map((slot, index) => {
        if (slot) {
            let slotToReturn = {
                state: slot.state,
                maturation: maturationProgress[index]
            };

            if (slot.state === "growing" || slot.state === "unmatured") {
                slotToReturn.card = {
                    type: "growing_fruit",
                    name: "Growing...",
                    imagePath: "gui/fishing_game/tree-back.png"
                };
            } else if (slot.state === "revealed") {
                if (slot.card && slot.card.imagePath) {
                    slotToReturn.card = slot.card;
                } else {
                    console.warn("Revealed slot missing card data or imagePath. Assigning fallback for UI.", slot);
                    slotToReturn.card = {
                        type: "error_card_missing_data",
                        name: "Corrupted Card Data",
                        imagePath: "gui/fishing_game/tree-back.png",
                        rarity: "unknown",
                        price: 0,
                        set: "fish_in_sea_error",
                        id: "error_missing_data"
                    };
                }
            }
            return slotToReturn;
        }
        return null;
    });
}

function collectCardFromTree(slotIndex) {
    console.log("[TreeMechanics] collectCardFromTree called for slotIndex", slotIndex);
    if (slotIndex < 0 || slotIndex >= treeSlots.length) {
        console.error(`Invalid slot index: ${slotIndex}`);
        return null;
    }

    const slot = treeSlots[slotIndex];
    if (slot && slot.state === "revealed" && slot.card) {
        const collectedCardDetails = slot.card;
        // console.log('[TreeCollect] Initial slot.card details:', JSON.parse(JSON.stringify(collectedCardDetails))); // REMOVE - Aggressive cleanup

        const cardDataForBasket = {
            id: collectedCardDetails.id,
            set: collectedCardDetails.set,
            name: collectedCardDetails.name,
            rarity: collectedCardDetails.rarity,
            rarityKey: collectedCardDetails.rarityKey || collectedCardDetails.rarity, // Ensure rarityKey is preferred if available
            price: collectedCardDetails.price, // Expect these to be defined by generateRandomCardForTree
            grade: collectedCardDetails.grade, // Expect these to be defined by generateRandomCardForTree
            imagePath: collectedCardDetails.imagePath,

            type: 'fruit_card', // Explicitly set as per categorization plan
            source: 'tree'      // Explicitly set
        };

        // Add checks for essential missing properties and log errors if so
        if (cardDataForBasket.id === undefined || cardDataForBasket.set === undefined ||
            cardDataForBasket.name === undefined || cardDataForBasket.imagePath === undefined ||
            cardDataForBasket.rarity === undefined || cardDataForBasket.price === undefined ||
            cardDataForBasket.grade === undefined ) { // Check for undefined explicitly
            console.error('[TreeCollect] CRITICAL: Missing essential details in cardDataForBasket from tree slot!',
                          JSON.parse(JSON.stringify(cardDataForBasket)),
                          'Original slot.card was:',
                          JSON.parse(JSON.stringify(collectedCardDetails)));
            // Optionally, create a full error object for cardDataForBasket here if needed
        }

        // console.log('[TreeCollect] Prepared cardDataForBasket:', JSON.parse(JSON.stringify(cardDataForBasket))); // REMOVE - Aggressive cleanup
        // The old log is now covered by the new [TreeCollect] log above.
        // console.log(`[TreeMechanics] Item for basket from tree slot ${slotIndex}: Name=${cardDataForBasket.name}, Type=${cardDataForBasket.type}, Source=${cardDataForBasket.source}`);

        if (typeof window.fishingBasket !== 'undefined' && typeof window.fishingBasket.addCardToBasket === 'function') {
            window.fishingBasket.addCardToBasket(cardDataForBasket, 1);

            // Standardize to use showCatchPreview
            if (typeof window.fishingUi !== 'undefined' && typeof window.fishingUi.showCatchPreview === 'function') {
                const itemTypeForPreview = (cardDataForBasket.type === 'collectible_card' || cardDataForBasket.type === 'fruit_card' || cardDataForBasket.type === 'mineral_card') ? 'card' : cardDataForBasket.type;
                const previewItem = {
                    type: itemTypeForPreview,
                    details: {
                        set: cardDataForBasket.set,
                        cardId: cardDataForBasket.id,
                        rarityKey: cardDataForBasket.rarityKey,
                        grade: cardDataForBasket.grade,
                        name: cardDataForBasket.name,
                        imagePath: cardDataForBasket.imagePath
                    }
                };
                window.fishingUi.showCatchPreview(previewItem);
            }
            // Fallback to showTemporaryCollectedItem removed to ensure single display path.
            // If showCatchPreview is not available, nothing will be shown by this function,
            // relying on the global display from addCardToBasket (which was also removed).
            // This means showCatchPreview becomes essential for any visual feedback from collection.
        } else {
            console.warn("fishingBasket.addCardToBasket function not found. Card not added to basket.");
        }

        treeSlots[slotIndex] = null;
        maturationProgress[slotIndex] = 0;
        slotTimers[slotIndex] = 0;

        if (typeof fishingTreeUi !== 'undefined' && typeof fishingTreeUi.renderTreeSlots === 'function') {
            fishingTreeUi.renderTreeSlots(getTreeSlotsData());
        }
        // console.log(`Slot ${slotIndex} cleared after collecting ${collectedCardDetails.name || 'item'}.`); // INFO
        return { ...collectedCardDetails };
    } else {
        // console.log(`No revealed card to collect in slot ${slotIndex}. Current state: ${slot ? slot.state : 'empty'}`); // INFO
        return null;
    }
}

function updateTreeMoisture(newMoisture) {
    const oldMoisture = treeMoisture;
    if (!constantMoistureActive) {
        treeMoisture = Math.max(0, Math.min(newMoisture, MAX_MOISTURE));
    } else {
        treeMoisture = MAX_MOISTURE;
    }

    if (treeMoisture !== oldMoisture || constantMoistureActive) {
        if (typeof fishingTreeUi !== 'undefined' && typeof fishingTreeUi.updateMoistureDisplay === 'function') {
            fishingTreeUi.updateMoistureDisplay(treeMoisture);
        }
    }
    // console.log(`Tree moisture updated to: ${treeMoisture}% (Constant moisture: ${constantMoistureActive})`); // INFO
}

function getTreeDataForSave() {
    return {
        treeSlots: treeSlots.map(slot => {
            if (slot && (slot.state === "growing" || slot.state === "unmatured")) {
                return {
                    state: "growing",
                    maturation: slot.maturation
                };
            }
            return slot ? { ...slot } : null;
        }),
        treeMoisture,
        slotTimers: [...slotTimers],
        maturationProgress: [...maturationProgress],
        constantMoistureActive,
    };
}

function loadTreeData(data) {
    if (!data) {
        console.error("No data provided to loadTreeData.");
        initializeTree();
        return;
    }

    treeSlots = data.treeSlots ? data.treeSlots.map((slotData, index) => { // Added index for logging
        if (slotData && (slotData.state === "growing" || slotData.state === "unmatured")) {
            return {
                state: "growing",
                maturation: slotData.maturation || 0,
                card: null
            };
        }
        // Ensure revealed slots from save have valid card data, assign fallback if not
        if (slotData && slotData.state === "revealed" && !slotData.card) {
            // console.warn(`[TreeLoad] Revealed slot ${index} from save data is missing card details. Assigning error fallback.`); // REMOVE - Aggressive cleanup
            slotData.card = {
                type: "error_card_save_load", name: "Corrupted Fruit",
                imagePath: "gui/fishing_game/tree-back.png",
                rarity: "unknown", price: 0, set: "fish_in_sea_error", id: "error_save_load",
                source: "tree" // Add source for consistency
            };
        }
        return slotData ? { ...slotData } : null;
    }) : Array(8).fill(null);

    treeMoisture = data.treeMoisture !== undefined ? data.treeMoisture : 100;
    slotTimers = data.slotTimers || Array(8).fill(0);
    maturationProgress = data.maturationProgress && data.maturationProgress.length === 8 ?
                         [...data.maturationProgress] :
                         treeSlots.map(slot => slot ? (slot.maturation || 0) : 0);

    constantMoistureActive = data.constantMoistureActive || false;

    if (constantMoistureActive) {
        treeMoisture = MAX_MOISTURE;
    }

    if (typeof fishingTreeUi !== 'undefined' && typeof fishingTreeUi.renderTreeSlots === 'function') {
        fishingTreeUi.renderTreeSlots(getTreeSlotsData());
    }
    if (typeof fishingTreeUi !== 'undefined' && typeof fishingTreeUi.updateMoistureDisplay === 'function') {
        fishingTreeUi.updateMoistureDisplay(treeMoisture);
    }
    // console.log("Tree data loaded:", getTreeDataForSave()); // INFO
}

window.initializeTree = initializeTree;
window.setConstantMoistureSupply = setConstantMoistureSupply;
window.updateTreeMoisture = updateTreeMoisture;
if (typeof window.getTreeSlotsData === 'undefined') {
    window.getTreeSlotsData = getTreeSlotsData;
}
if (typeof window.collectCardFromTree === 'undefined') {
    window.collectCardFromTree = collectCardFromTree;
}

console.log("tree-mechanics.js loaded with UI integration points and new generation logic.");
